import os
import openai
import json
from django.conf import settings
from .models import Recipe, Ingredient, RecipeCategory

class AIRecipeGenerator:
    def __init__(self, user):
        openai.api_key = settings.OPENAI_API_KEY
        self.user = user

    def _construct_prompt(self, dietary_preferences=None, cuisine=None, difficulty=None):
        """Construct a detailed prompt for recipe generation."""
        prompt_parts = [
            "Create a unique, delicious recipe with the following specifications:",
            f"Dietary Preferences: {dietary_preferences or 'None specified'}",
            f"Cuisine Style: {cuisine or 'Global fusion'}",
            f"Difficulty Level: {difficulty or 'Intermediate'}",
            "Include: Ingredients list, step-by-step instructions, cooking time, servings, nutritional info."
        ]
        return "\n".join(prompt_parts)

    def generate_recipe(self, dietary_preferences=None, cuisine=None, difficulty=None):
        """Generate an AI-powered recipe."""
        # Check if user has access to AI recipes
        if not self.user.is_premium_user:
            return {
                'error': 'Premium access required',
                'unlock_options': [
                    'Watch a video ad',
                    'Purchase premium subscription'
                ]
            }

        prompt = self._construct_prompt(dietary_preferences, cuisine, difficulty)
        
        try:
            response = openai.ChatCompletion.create(
                model="gpt-4-turbo",
                messages=[
                    {"role": "system", "content": "You are a professional chef creating unique, delicious recipes."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=1000
            )

            recipe_text = response.choices[0].message.content
            
            # Parse the recipe
            parsed_recipe = self._parse_recipe(recipe_text)
            
            # Save to database
            recipe = self._save_recipe(parsed_recipe)
            
            return recipe

        except Exception as e:
            return {
                'error': f'Recipe generation failed: {str(e)}'
            }

    def _parse_recipe(self, recipe_text):
        """Parse the raw recipe text into a structured format."""
        try:
            # Use OpenAI to help parse the recipe
            parse_prompt = f"""
            Parse the following recipe text into a JSON format:
            {recipe_text}

            JSON Format:
            {{
                "name": "",
                "description": "",
                "ingredients": [
                    {{"name": "", "quantity": "", "unit": ""}}
                ],
                "instructions": [""],
                "cooking_time": "",
                "servings": "",
                "nutritional_info": {{
                    "calories": "",
                    "protein": "",
                    "carbs": "",
                    "fat": ""
                }}
            }}
            """

            parse_response = openai.ChatCompletion.create(
                model="gpt-4-turbo",
                messages=[
                    {"role": "system", "content": "You are an expert at parsing recipe text into structured JSON."},
                    {"role": "user", "content": parse_prompt}
                ]
            )

            parsed_json = json.loads(parse_response.choices[0].message.content)
            return parsed_json

        except Exception as e:
            # Fallback to manual parsing if AI parsing fails
            return self._manual_parse(recipe_text)

    def _manual_parse(self, recipe_text):
        """Manual fallback parsing of recipe text."""
        # Implement basic parsing logic
        return {
            "name": "AI Generated Recipe",
            "description": "Unique recipe generated by AI",
            "ingredients": [],
            "instructions": [recipe_text],
            "cooking_time": "Unknown",
            "servings": "4",
            "nutritional_info": {}
        }

    def _save_recipe(self, parsed_recipe):
        """Save the parsed recipe to the database."""
        recipe = Recipe.objects.create(
            name=parsed_recipe['name'],
            description=parsed_recipe.get('description', ''),
            cooking_time=parsed_recipe.get('cooking_time', ''),
            servings=parsed_recipe.get('servings', '4'),
            nutritional_info=json.dumps(parsed_recipe.get('nutritional_info', {})),
            created_by=self.user
        )

        # Save ingredients
        for ing_data in parsed_recipe.get('ingredients', []):
            ingredient = Ingredient.objects.create(
                name=ing_data.get('name', ''),
                quantity=ing_data.get('quantity', ''),
                unit=ing_data.get('unit', '')
            )
            recipe.ingredients.add(ingredient)

        # Save instructions
        recipe.instructions = json.dumps(parsed_recipe.get('instructions', []))
        recipe.save()

        return recipe

    def generate_smart_grocery_list(self, meal_plan):
        """Generate a smart grocery list based on meal plan."""
        ingredients = []
        for meal in meal_plan.meals.all():
            ingredients.extend(meal.recipe.ingredients.all())
        
        # Consolidate ingredients
        grocery_list = {}
        for ingredient in ingredients:
            key = f"{ingredient.name}_{ingredient.unit}"
            if key in grocery_list:
                grocery_list[key]['quantity'] += float(ingredient.quantity)
            else:
                grocery_list[key] = {
                    'name': ingredient.name,
                    'quantity': float(ingredient.quantity),
                    'unit': ingredient.unit
                }
        
        return list(grocery_list.values())
